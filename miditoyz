#!/usr/bin/env python3

# Copyright (c) 2023 Dirk Leas
# This software is released under the MIT License.
# https://opensource.org/licenses/MIT

#
# miditoyz - care and feeding for you midi song collection
#
# notes/references:
#   - duckdb is used for catalog and metadata storage
#   - reference song with rich meta, sysex and sequencer_specific events in my
#     personal collection:
#       clav.toys/more clav files/2.NEW FollowLights/02.Prelude.s944.mid
#

import os, hashlib, shutil, json, csv, pathlib, platform, pickle, time, datetime, random, string, mido, typer, textwrap, duckdb, jinja2
from collections import defaultdict
from typing import List, Optional

homedir = pathlib.Path.home()


def oops(msg: str, prefix: str = "") -> None:
    typer.echo(typer.style(f"{prefix}oops, {msg}", fg=typer.colors.RED, bold=True))


if not os.path.exists(pathlib.Path(homedir) / ".miditoyz"):
    oops(
        "you need to complete all the Initial Installation steps from the project README.md documentation before you can use miditoyz"
    )
    exit(1)


def map_voicing(voicing: str) -> dict:
    """map voicing name to voice preferences with "from" voice being either a single voice or a list of voices"""
    voicings = settings.get("voicings")
    if not voicing in voicings:
        return {}
    else:
        result = {}
        for k, v in voicings.get(voicing).items():
            if isinstance(v[0][0], int):
                result[tuple(v[0])] = tuple(v[1])
            else:
                for voice in v[0]:
                    result[tuple(voice)] = tuple(v[1])
        return result


try:
    settings = json.load(open(pathlib.Path(homedir) / ".miditoyz" / "settings.json"))
except:
    oops("your settings.json file is broken, please fix it and try again")
    exit(1)

voicing_default = map_voicing(settings.get("voicing_default"))

app = typer.Typer()


def is_midi(filename: str) -> bool:
    return filename.lower().endswith((".midi", ".mid"))


def normalize_midi(midi_file: str) -> str:
    """optionally prefix catalog path for unqualified catalog midi files and append .mid if not specified"""
    if not is_midi(midi_file):
        midi_file += ".mid"
    catalog_path = str(pathlib.Path(settings.get("catalog")) / midi_file)
    if (
        is_midi(midi_file)
        and not os.path.exists(midi_file)
        and os.path.exists(catalog_path)
    ):
        return catalog_path
    else:
        return midi_file


def get_track_channel_voices(midi_file: str, midi, voices: dict, echo=True) -> None:
    result = [
        f"MIDI File: {midi_file}",
    ]
    for i, track in enumerate(midi.tracks):
        channels = defaultdict(dict)
        channels_over_time = defaultdict(dict)
        time_elapsed = 0
        result.append(f"  Track: {i}")
        for msg in track:
            time_elapsed += msg.time
            if msg.type == "track_name":
                result.append(f'    Track Name: {track.name.strip() or "n/a"}')
            elif msg.type == "control_change" and msg.control == 0:
                channels[msg.channel]["msb"] = msg.value
            elif msg.type == "control_change" and msg.control == 32:
                channels[msg.channel]["lsb"] = msg.value
            elif msg.type == "program_change":
                channels[msg.channel]["pc"] = msg.program + 1
                channels_over_time[msg.channel, time_elapsed] = channels[msg.channel]
                del channels[msg.channel]
        for channel in sorted(channels_over_time):
            voice = (
                channels_over_time.get(channel).get("msb", 0),
                channels_over_time.get(channel).get("lsb", 0),
                channels_over_time.get(channel).get("pc", 1),
            )
            if voice in voices.keys():
                result.append(
                    f"      Channel {channel[0]} @{channel[1]}: {voices.get(voice, voice)}, datalist voice MSB, LSB, PC: [{voice[0]}, {voice[1]}, {voice[2]}]"
                )
            else:
                result.append(
                    f"      Channel {channel[0]} @{channel[1]}: {voices.get(voice, voice)}: unrecognized voice, MSB, LSB, PC: [{voice[0]}, {voice[1]}, {voice[2]}]"
                )
    result = os.linesep.join(result)
    if echo:
        typer.echo(result)
    else:
        return result


def printable(s: str) -> str:
    """return printable string"""
    return "".join(filter(lambda x: x in string.printable, s))


def get_title(midi: mido.MidiFile) -> str:
    """return song title from midi file object"""
    titles = [e.name for e in midi.tracks[0] if e.type == "track_name"]
    return printable(titles[0]).strip() if titles and len(titles) > 0 else "untitled"


def create_db(catalog: str) -> None:
    db = f'{pathlib.Path(catalog) / "catalog.db"}'
    if os.path.exists(db):
        os.remove(db)
    typer.echo(f"  creating duckdb database {db}, just a sec...")
    conn = duckdb.connect(db, config={"max_memory": "5G"})
    catalog_data = [
        {"id": k, **v} for k, v in json.load(open(db.replace(".db", ".json"))).items()
    ]
    open(db.replace(".db", "_flat.json"), "w").write(json.dumps(catalog_data))
    catalog_flat = db.replace(".db", "_flat.json")
    conn.execute(
        "create table catalog as select * from read_json('"
        + catalog_flat
        + "', columns={id: 'varchar', title: 'varchar', broken: 'boolean', dump: 'varchar', voices: 'varchar', sources: 'varchar'});"
    )
    conn.execute(
        """
        alter table catalog add column favorite boolean default false;
        alter table catalog add column note varchar;
        create unique index idx_catalog_id on catalog (id);
        create table tag (id varchar, value varchar);
        create unique index idx_tag on tag (id, value);
        create table genre (id varchar, value varchar);
        create unique index idx_genre on genre (id, value);
        """
    )
    conn.commit()
    conn.close()
    os.remove(catalog_flat)


def ingest_music(
    source_directory: str, destination_directory: str, voices: dict
) -> int:
    """ingest music from source_directory into destination_directory"""
    typer.echo(
        f"ingesting source_directory: {source_directory} => destination_directory: {destination_directory}..."
    )
    # locate candidate songs, hash for duplicates...
    typer.echo(f"  scanning for duplicate songs...")
    songs = defaultdict(lambda: defaultdict(list))
    total_songs = 0  # total songs found, including dups...
    for dirpath, _, filenames in os.walk(source_directory):
        for filename in filenames:
            if is_midi(filename):
                total_songs += 1
                song = os.path.join(dirpath, filename)
                hash = hashlib.md5(open(song, "rb").read()).hexdigest()
                songs[hash]["sources"].append(song)
    typer.echo(
        f"  found {total_songs} total songs of which {len(songs)} are actually unique..."
    )

    # copy unique songs to destination_directory...
    typer.echo(f"  copying unique songs to {destination_directory}...")
    for hash, v in songs.items():  # fyi, this took 1m5.3s
        shutil.copyfile(
            v["sources"][0], pathlib.Path(destination_directory) / f"{hash}.mid"
        )

    # add metadata to catalog using dump_json --metadata...
    typer.echo("  gathering songs metadata and voicings, this takes a while...")
    songs_broken = set()
    for i, song in enumerate(songs.keys()):
        if i % 1000 == 0 and i > 0:
            typer.echo(f"    {i} of {len(songs)} songs processed...")
        try:
            dump = voice_dump = None
            midi_filename = pathlib.Path(destination_directory) / f"{song}.mid"
            midi = mido.MidiFile(midi_filename)
            dump = dump_json(midi, metadata=True).strip()
            voice_dump = get_track_channel_voices(
                midi_filename, midi, voices, echo=False
            ).strip()
            songs[song] = {
                **{
                    "title": get_title(midi),
                    "broken": False,
                    "dump": dump,
                    "voices": voice_dump,
                    "timestamp": datetime.datetime.now().isoformat(),
                },
                **songs[song],
            }
        except:
            # import traceback
            # print(f"song: {song}{os.linesep}{traceback.format_exc()}")
            songs_broken.add(song)
            songs[song] = {
                **{
                    "title": get_title(midi),
                    "broken": True,
                    "dump": dump or "n/a",
                    "voices": voice_dump or "n/a",
                    "timestamp": datetime.datetime.now().isoformat(),
                },
                **songs[song],
            }
    typer.echo(
        f'  {len(songs_broken) / len(songs) * 100:.2f}% of songs are "broken" and have been logged...'
    )
    json.dump(
        songs, open(pathlib.Path(destination_directory) / "catalog.json", "w"), indent=2
    )
    settings = json.load(open(pathlib.Path(homedir) / ".miditoyz" / "settings.json"))
    settings["catalog"] = str(pathlib.Path(destination_directory))
    settings["music"] = ""
    json.dump(
        settings, open(pathlib.Path(homedir) / ".miditoyz" / "settings.json", "w")
    )
    create_db(settings.get("catalog"))
    typer.echo(
        f"  song catalog saved to {pathlib.Path(destination_directory) / 'catalog.json'}"
    )
    return len(songs)


def format_query_result(data: list) -> str:
    if not data:
        oops("no songs match your query")
        return
    HORIZONTAL = "─"
    VERTICAL = "│"
    TOP_LEFT = "┌"
    TOP_RIGHT = "┐"
    BOTTOM_LEFT = "└"
    BOTTOM_RIGHT = "┘"
    T_LEFT = "├"
    T_RIGHT = "┤"
    T_TOP = "┬"
    T_BOTTOM = "┴"
    CROSS = "┼"
    max_width_col1 = max(len(row[0]) for row in data)
    max_width_col2 = max(len(row[1]) for row in data)
    header_top = f"{TOP_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{T_TOP}{HORIZONTAL * (max_width_col2 + 2)}{TOP_RIGHT}"
    header_row = f"{VERTICAL} {'id'.ljust(max_width_col1)} {VERTICAL} {'title'.ljust(max_width_col2)} {VERTICAL}"
    header_middle = f"{T_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{CROSS}{HORIZONTAL * (max_width_col2 + 2)}{T_RIGHT}"
    rows_box = [header_top, header_row, header_middle]
    for row in data:
        rows_box.append(
            f"{VERTICAL} {row[0].strip().ljust(max_width_col1)} {VERTICAL} {row[1].strip().ljust(max_width_col2)} {VERTICAL}"
        )
    table_bottom = f"{BOTTOM_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{T_BOTTOM}{HORIZONTAL * (max_width_col2 + 2)}{BOTTOM_RIGHT}"
    rows_box.append(table_bottom)
    return "\n".join(rows_box)


def notify(title: str, subtitle: str) -> None:
    """display notification on macos, tested on ventura"""
    try:
        if platform.system() == "Darwin":
            import sh

            sh.osascript(e=f'display notification "{title}" with title "{subtitle}"')
        elif platform.system() == "Windows":
            import notifypy, string

            notification = notifypy.Notify()
            notification.application_name = "miditoyz - streaming..."
            notification.title = subtitle
            notification.message = title
            notification.send(block=False)
    except:
        pass


def serialize_settings(new_settings: dict) -> None:
    """update settings.json with specified dictionary"""
    settings.update(new_settings)
    json.dump(
        settings,
        open(pathlib.Path(homedir) / ".miditoyz" / "settings.json", "w"),
    )


def generate_midi_voice_events(ch: int, msb: int, lsb: int, pc: int) -> list:
    """generate midi voice events for bank select and program change messages"""
    return [
        mido.Message("control_change", channel=ch, control=0, value=msb, time=0),
        mido.Message("control_change", channel=ch, control=32, value=lsb, time=0),
        mido.Message("program_change", channel=ch, program=pc - 1, time=0),
    ]


def stream_preferred_voicing(
    midi_file: str, index: int, song_count: int, voicings: dict, device
) -> None:
    """revoice midi file with voice preferences"""
    channels = defaultdict(dict)
    serialize_settings({"song": midi_file, "bookmark": index + 1})
    try:
        midi = mido.MidiFile(midi_file)
        title = get_title(midi)
        typer.echo(f"{title} ({midi_file}), song {index+1} of {song_count}")
        notify(f"{'/'.join(midi_file.split('/')[-2:])}, #{index+1}", title)
        for event in midi.play():
            if event.type == "control_change" and event.control == 0:
                channels[event.channel]["msb"] = event.value
            elif event.type == "control_change" and event.control == 32:
                channels[event.channel]["lsb"] = event.value
            elif event.type == "program_change":
                ch = event.channel
                channels[ch]["pc"] = event.program + 1
                voice = (
                    channels.get(ch).get("msb", 0),
                    channels.get(ch).get("lsb", 0),
                    channels.get(ch).get("pc", 1),
                )
                voicing = voicings.get(voice, voice)
                if voice == voicing:
                    typer.echo(f"  voicing channel {ch} with voice {voice}")
                else:
                    typer.echo(
                        f"  revoicing channel {ch} from voice {voice} to preferred voice {voicing}"
                    )
                for voice_event in generate_midi_voice_events(
                    *tuple([*[ch], *voicing])
                ):
                    device.send(voice_event)
            else:
                device.send(event)
    except KeyboardInterrupt:
        exit(0)
    except:
        oops(f"{midi_file} is a broken song file")


def merge_json_metadata(data, types_to_merge=["text", "copyright", "lyrics"]):
    merged_records = defaultdict(str)
    first_record_index = {}
    output_data = []

    # Iterate through the list to find and merge records of specified types
    for i, record in enumerate(data):
        record_type = record.get("type")
        if record_type in types_to_merge:
            if record_type not in first_record_index:
                first_record_index[record_type] = i
                merged_records[record_type] = record["text"]
            else:
                merged_records[record_type] += "\n" + record["text"]
        else:
            output_data.append(record)

    # Replace the first instance of each merged type with the merged text
    for record_type, index in first_record_index.items():
        output_data.insert(
            index, {"type": record_type, "text": merged_records[record_type], "time": 0}
        )

    return output_data


def dump_json(midi, metadata: bool = True, raw_json: bool = False) -> str:
    """dump midi object in raw json format"""
    tracks = []
    for i, track in enumerate(midi.tracks):
        events = []
        for event in track:
            if metadata and (
                event.type in settings.get("performanceEvents")
                or (event.type == "control_change" and not event.control in [0, 32])
                or event.type == "end_of_track"
                or event.type.startswith("sequencer_specific")
            ):
                pass
            else:
                events.append(vars(event).copy())
        events = merge_json_metadata(events)
        tracks.append({"track": i, "events": events})
    song = (
        {
            "ticks_per_beat": midi.ticks_per_beat,
            "tracks": tracks,
        },
    )
    if raw_json:
        return json.dumps(
            song,
            indent=2,
        )
    else:
        return (
            jinja2.Environment()
            .from_string(open(pathlib.Path(settings.get("root")) / "midi.j2").read())
            .render(song[0])
        )


def create_query(
    title: Optional[str] = None,
    metadata: Optional[str] = None,
    favorite: bool = False,
    tags: List[str] = [],
    genres: List[str] = [],
    note: Optional[str] = None,
    sources: Optional[str] = None,
    voices: Optional[str] = None,
    connective: Optional[str] = "OR",
):
    select_stmt = "SELECT id, title FROM catalog"
    where_conditions = []

    def prepare_conditions(field, values, connective):
        if values:
            search_terms = [f"%{value.lower().strip()}%" for value in values.split()]
            return f" {connective} ".join(
                [f"LOWER({field}) LIKE '{term}'" for term in search_terms]
            )
        return None

    def compose_related_values(table, column, values, connective):
        conditions = f" {connective} ".join(
            [
                f"id IN (SELECT id FROM {table} WHERE LOWER({column}) = '{value.lower()}')"
                for value in values
            ]
        )
        where_conditions.append(f"({conditions})")

    if title:
        condition = prepare_conditions("title", title, connective)
        if condition:
            where_conditions.append(f"({condition})")
    if metadata:
        condition = prepare_conditions("dump", metadata, connective)
        if condition:
            where_conditions.append(f"({condition})")
    if sources:
        condition = prepare_conditions("sources", sources, connective)
        if condition:
            where_conditions.append(f"({condition})")
    if voices:
        condition = prepare_conditions("voices", voices, connective)
        if condition:
            where_conditions.append(f"({condition})")
    if favorite:
        where_conditions.append("favorite = TRUE")
    if tags:
        conditions = compose_related_values("tag", "value", tags, connective)
        if conditions:
            where_conditions.append(f"({conditions})")
    if genres:
        conditions = compose_related_values("genre", "value", genres, connective)
        if conditions:
            where_conditions.append(f"({conditions})")
    if note:
        condition = prepare_conditions("note", note, connective)
        if condition:
            where_conditions.append(f"({condition})")
    if where_conditions:
        select_stmt += " WHERE " + f" {connective} ".join(where_conditions)
    return select_stmt


def list_music(music) -> list:
    """list music from a catalog song list, a midi file, directory full of midi files, or last music played"""
    if music.lower() == "last":  # last music played...
        songs = [
            settings.get("song"),
        ]
    elif is_midi(music):  # file...
        music = normalize_midi(music)
        songs = [
            music,
        ]
    elif os.path.isdir(music):  # folder's midi files...
        songs = sorted([f"{music}{os.sep}{x}" for x in os.listdir(music) if is_midi(x)])
    elif music.lower().endswith(".csv") and os.path.exists(
        music
    ):  # stream or catalog list...
        songs = list(  # includes header, format title,id
            map(
                lambda x: f'{settings.get("catalog")}{os.sep}{x.get("id")}.mid',
                csv.DictReader(open(music)),
            )
        )
    else:
        oops(
            "music must be a song list, valid midi file ending .mid, or directory full of midi files"
        )
        return
    return songs


@app.command()
def init(
    source_directory: pathlib.Path = typer.Argument(
        ..., help="Directory full of MIDI songs to clean up."
    ),
    destination_directory: pathlib.Path = typer.Argument(
        ...,
        help="Directory for cleaned up MIDI song collection with duplicates removed and catalog generated.",
    ),
    voices: str = typer.Option(
        str(pathlib.Path(settings.get("root")) / "datalist.pickle"),
        help='Official Yamaha Clavinova "datalist" of voices. Check vendor documentation for other device voicing.',
    ),
):
    """Generate a new music collection from a source directory into a destination directory removing duplicates
    songs. Duplicates include same song in multiple directory paths, renamed versions of the same song, etc.
    that have identical song content "inside" the song MIDI file."""
    if not os.path.exists(source_directory):
        oops(f"source_directory {source_directory} doesn't exist")
        return
    if source_directory == destination_directory:
        oops(f"source_directory and destination_directory must be different")
        return
    if not os.path.exists(destination_directory):
        os.makedirs(destination_directory)
    else:
        oops(f"destination_directory {destination_directory} already exists")
        return

    start_time = time.time()
    songs = ingest_music(
        source_directory, destination_directory, pickle.load(open(voices, "rb"))
    )
    elapsed = (time.time() - start_time) / 60  # minutes
    typer.echo(
        f"  elapsed time was {elapsed:.2f} minutes, {elapsed/songs*1000:.2f} minutes/1000 songs..."
    )


@app.command()
def merge(
    source: str = typer.Argument(
        ..., help="Source catalog to merge into destination catalog."
    ),
    destination: str = typer.Argument(
        ...,
        help="Destination catalog to merge source catalog into, overriding duplicates with source songs.",
    ),
    backup: bool = typer.Option(
        True, help="Create destination catalog backup .zip archive before merging."
    ),
):
    """Merge source JSON catalog into destination JSON catalog, overwriting destination catalog songs with
    source catalog songs if there are any duplicates -- this is only merging JSON files, not the catalog
    database or user metadata.
    """
    if (
        not os.path.exists(source)
        and os.path.isdir(source)
        and os.path.exists(pathlib.Path(destination) / "catalog.json")
    ):
        oops("source catalog {source} isn't a valid catalog")
        return
    if (
        not os.path.exists(destination)
        and os.path.isdir(source)
        and os.path.exists(pathlib.Path(destination) / "catalog.json")
    ):
        oops("destination catalog {destination} isn't a valid catalog")
        return
    typer.echo(
        f"merging source catalog {source} into destination catalog {destination}..."
    )
    if backup:
        typer.echo(f"  backing up destination catalog...")
        shutil.make_archive(
            f"{destination}.backup.{datetime.datetime.now().isoformat().replace(':', '.')}",
            "zip",
            destination,
        )
    typer.echo(f"  merging catalogs...")
    source_catalog = json.load(open(pathlib.Path(source) / "catalog.json"))
    destination_catalog = json.load(open(pathlib.Path(destination) / "catalog.json"))
    dupes = len(set(source_catalog).intersection(set(destination_catalog)))
    typer.echo(
        f"  merging {len(source_catalog)} source songs with destination: {len(destination_catalog)} destination songs, {dupes} duplicates..."
    )
    destination_catalog.update(source_catalog)
    json.dump(
        destination_catalog,
        open(pathlib.Path(destination) / "catalog.json", "w"),
        indent=2,
    )
    create_db(destination.replace(".json", ""))
    typer.echo(f"  merged catalog saved to {destination}")


@app.command()
def devices():
    """List currently connected midi output devices attached via USB, WIFI, or Bluetooth."""
    typer.echo("connected midi device(s):")
    for device in mido.get_output_names():
        typer.echo(f'  "{device}"')


@app.command()
def stream(
    music: str = typer.Option(
        settings.get("music") or settings.get("catalog"),  # default to last music
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id". You can specify "LAST" for last song streamed.',
    ),
    bookmark: int = typer.Option(
        settings.get("bookmark", 0),
        help="Bookmark for last song played assuming you don't pick different music.",
    ),
    skip: bool = typer.Option(
        False,
        help="Skip to next song in music list if not shuffling instead of replaying bookmarked song.",
    ),
    device: str = typer.Option(
        settings.get("device", "Clavinova Port 1"),
        help='MIDI device to stream to (e.g. "Clavinova Port 1" for USB, "Network Clavinova for WIFI, etc.))',
    ),
    voicing: str = typer.Option("", help="Voicing to use for voice preferences."),
    shuffle: bool = typer.Option(False, help="Shuffle song order."),
    repeat: bool = typer.Option(False, help="Repeat your music forever."),
    intermission: int = typer.Option(
        0, help="Add specified number of seconds intermission between songs."
    ),
    debug: bool = typer.Option(
        False,
        help="Debug output.))",
    ),
):
    """
    Stream music from a catalog song list, a midi file, or directory full of midi files to a midi device with using
    bank selection and program changes based on voice preferences stored in your home directory on Windows as
    ".miditoyz\settings.json" or ".miditoyz/settings.json" on MacOS/Linux. Your last song played
    and saved automatically each time you stream.

    Catalog song lists are CSV files with a mandatory header of "title,id" -- don't forget to use comma to separate for
    CSV fields, and double-quote fields with commas in them. Create song lists using the "query" command.

    Bookmark values are based on the sequential number of the song in the playlist or directory song list starting with 1.
    We do the right thing if you specify a bookmark number that's too big or small or your play different music than
    last time. Don't want to play your songs in order? Try the "shuffle" option. Your most important command line options are
    remembered between streaming sessions, so subsequent streamings pick up from the last song played if you don't include
    them (streaming exceptions: shuffle, intermission, and debug).
    """
    if voicing and not voicing in settings.get("voicings"):
        oops("no such voicing in your current voicings list")
        return
    try:  # pretest device...
        mido.open_output(device)
    except:
        oops(
            f"device {device} not found, please select from the following connected device list: {', '.join(set(mido.get_output_names()))}"
        )
        return
    if bookmark < 0 or music != settings.get("music") or is_midi(music):
        bookmark = 1
    serialize_settings({"music": music, "device": device, "bookmark": bookmark})
    songs = list_music(music)
    if skip:
        bookmark += 1
    if bookmark > len(songs):
        bookmark = 1
        oops(
            f"your bookmark is beyond the last song in your music -- starting from the beginning...{os.linesep}"
        )
    try:  # revoice and stream songs...
        if shuffle:
            bookmark = 1
            random.shuffle(songs)
        device = mido.open_output(device)
        for idx, song in enumerate(songs):
            if idx >= bookmark - 1:
                stream_preferred_voicing(
                    song,
                    idx,
                    len(songs),
                    map_voicing(voicing) or voicing_default,
                    device,
                )
                time.sleep(intermission)
        if repeat:
            stream(
                music,
                bookmark,
                device.name,
                voicing,
                shuffle,
                repeat,
                intermission,
                debug,
            )
    except:  # ignore broken songs...
        if not debug:
            pass
        else:  # debug...
            raise


@app.command()
def voices(
    music: str = typer.Argument(
        ...,
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id" to generate voice list(s) for. You can specify "LAST" for last song streamed.',
    ),
    voices: str = typer.Option(
        str(pathlib.Path(settings.get("root")) / "datalist.pickle"),
        help='Official Yamaha Clavinova "datalist" of voices. Check vendor documentation for other device voicing.',
    ),
):
    """Generate a list of voices for each track in a midi song file."""
    music = list_music(music)
    typer.echo(f"MUSIC VOICES{os.linesep}============")
    for midi_file in music:
        try:
            midi = mido.MidiFile(midi_file)
            get_track_channel_voices(midi_file, midi, pickle.load(open(voices, "rb")))
        except:
            oops(f"{midi_file} is a broken song file")
        if len(music) > 1:
            typer.echo(
                f'{os.linesep}{"~"*shutil.get_terminal_size().columns}{os.linesep}'
            )


@app.command()
def dump(
    music: str = typer.Argument(
        ...,
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id" to be analyzed. You can specify "LAST" for last song streamed.',
    ),
    metadata: bool = typer.Option(False, help="Show only metadata."),
    json: bool = typer.Option(False, help="Convert MIDI song to raw JSON."),
):
    """Dump a MIDI song file in raw text format. See also: "miditoyz raw --debug"."""
    music = list_music(music)
    if len(music) > 1 and not json:
        typer.echo(f"MUSIC DUMP{os.linesep}==========")
    elif json:
        typer.echo("[")
    for midi_file in music:
        try:
            midi = mido.MidiFile(midi_file)
            if not json:
                typer.echo(f"MIDI File: {midi_file}")
            typer.echo(dump_json(midi, metadata, json))
        except:
            oops(f"{midi_file} is a broken song file")
        if len(music) > 1 and not json:
            typer.echo(
                f'{os.linesep}{"~"*shutil.get_terminal_size().columns}{os.linesep}'
            )
        elif json and midi_file != music[-1]:
            typer.echo(",")
    if json:
        typer.echo("]")


@app.command()
def raw(
    music: str = typer.Argument(
        ...,
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id" to be analyzed. You can specify "LAST" for last song streamed.',
    ),
    debug: bool = typer.Option(False, help="Enable extended raw debug mode."),
):
    """Dump a MIDI song file in alternative raw text format with optionally with hexdump-style debug output. See also: "miditoyz dump --metadata"."""
    music = list_music(music)
    typer.echo(f"MUSIC RAW DUMP{os.linesep}==============")
    for midi_file in music:
        try:
            mido.MidiFile(midi_file, debug=debug).print_tracks()
        except:
            oops(f"{midi_file} is a broken song file")
        if len(music) > 1:
            typer.echo(
                f'{os.linesep}{"~"*shutil.get_terminal_size().columns}{os.linesep}'
            )


@app.command()
def summarize(
    music: str = typer.Argument(
        ...,
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id" to be summarized. You can specify "LAST" for last song streamed.',
    ),
):
    """Summarize MIDI song metadata and voices (e.g. convenience command which runs both dump with metadata and voices commands)."""
    music = list_music(music)
    for midi_file in music:
        typer.echo(f"SUMMARY{os.linesep}=======")
        typer.echo(f"METADATA{os.linesep}--------")
        dump(midi_file, metadata=True, json=False)
        typer.echo(f"VOICES{os.linesep}------")
        voices(midi_file, str(pathlib.Path(settings.get("root")) / "datalist.pickle"))
        if len(music) > 1:
            typer.echo(
                f'{os.linesep}{"~"*shutil.get_terminal_size().columns}{os.linesep}'
            )


@app.command()
def verify(
    file_name: str = typer.Argument(
        ..., help="MIDI song, JSON, or CSV file to verify for correct format."
    )
):
    """Verify MIDI song file can be processed with mido package or that a JSON or CSV file is the correct format."""
    if not os.path.exists(file_name) or not (
        is_midi(file_name)
        or file_name.lower().endswith(".json")
        or file_name.lower().endswith(".csv")
    ):
        oops(
            f"specified {file_name} doesn't exist or isn't a midi song, JSON, or CSV file"
        )
        return
    if is_midi(file_name):
        typer.echo(f"verifying {file_name} with mido...")
        try:
            mido.MidiFile(file_name)
            typer.echo(f"  mido ok!")
        except:
            oops(f"unable to verify with mido", prefix="  ")
    elif file_name.lower().endswith(".json"):
        typer.echo(f"verifying {file_name} is a valid JSON file...")
        try:
            json.load(open(file_name))
            typer.echo(f"  JSON format ok")
        except:
            oops(f"invalid format", prefix="  ")
    else:
        typer.echo(f"verifying {file_name} is a valid CSV file...")
        try:
            csv.DictReader(open(file_name))
            typer.echo(f"  CSV format ok")
        except:
            oops(f"invalid format", prefix="  ")


@app.command()
def catalog(
    catalog_directory: str = typer.Argument(
        ...,
        help="Alternative catalog directory from one of your miditoyz song collections.",
    )
):
    """Change to a new catalog file for streaming."""
    if os.path.exists(catalog_directory):
        serialize_settings({"catalog": catalog_directory, "music": "", "bookmark": 1})
    else:
        oops(f"{catalog_directory} doesn't exist or isn't a catalog json file")


@app.command()
def voicing(
    instrument_name: str = typer.Argument(..., help="Instrument name from voices.")
):
    """Change to a new instrument name for voicing streams."""
    if settings.get("voices").get(instrument_name, "not found") == "not found":
        oops(f"{instrument_name} isn't a valid instrument name")
    else:
        serialize_settings({"instrument": instrument_name})


@app.command()
def info(
    json: bool = typer.Option(False, help="Convert info to JSON."),
):
    """Show current miditoyz settings, including user metadata tags and genres."""
    from json import dumps

    def to_dict(sql_list, columns):
        return [{columns[i]: row[i] for i in range(len(columns))} for row in sql_list]

    result = {"settings": settings, "metadata": {}}
    conn = duckdb.connect(f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}')
    for table in ["tag", "genre"]:
        result["metadata"][table] = to_dict(
            conn.execute(
                f"select value, count(*) as uses from {table} group by value order by count(*) desc;"
            ).fetchall(),
            ["value", "count"],
        )
    if json:
        typer.echo(dumps(result, indent=2))
    else:
        typer.echo(f"miditoyz settings:")
        for k, v in sorted(settings.items()):
            if k == "voicings":
                typer.echo(f"  {k}")
                for title, mapping in v.items():
                    typer.echo(f"    {title}: {mapping}")
            elif k == "performanceEvents":
                typer.echo(f"  {k}:")
                for line in textwrap.wrap(
                    v, width=shutil.get_terminal_size().columns - 4
                ):
                    typer.echo(f"    {line}")
            else:
                typer.echo(f"  {k}: {v}")
        typer.echo("  metadata:")
        for table, values in result["metadata"].items():
            typer.echo(f"    {table}:")
            for value in values:
                typer.echo(f"      {value['value']}: {value['count']}x")


@app.command()
def query(
    title: Optional[str] = typer.Option(None, help="Query catalog song title."),
    metadata: Optional[str] = typer.Option(
        None, help="Query catalog song metadata, excluding user provided metadata."
    ),
    sources: Optional[str] = typer.Option(None, help="Query catalog song sources."),
    voices: Optional[str] = typer.Option(None, help="Query catalog song voicing."),
    favorite: bool = typer.Option(
        False, help="Query catalog for songs that are marked as favorites."
    ),
    tag: List[str] = typer.Option(
        [],
        help="Query catalog with a list of one or more tags (e.g. --tag piano --tag karaoke).",
    ),
    genre: List[str] = typer.Option(
        [],
        help="Query catalog with a list of one or more genres (e.g. --genre jazz --genre newOrleans).",
    ),
    note: Optional[str] = typer.Option(None, help="Query catalog song note."),
    sql: Optional[str] = typer.Option(
        None, help="Query using raw SQL (experts only!)."
    ),
    save: str = typer.Option(
        None,
        help="Save your song list query result to a .csv file for use with streaming or adding user metadata.",
    ),
    debug: bool = typer.Option(
        False, help="Show SQL generated based on selected query option."
    ),
    connective: Optional[str] = typer.Option(
        "OR", help="Use OR or AND logic when using multiple options."
    ),
):
    """Query a song list from your catalog for streaming or managing user metadata
    with several options to choose from depending on whether you prefer a simple or
    advanced capabilities. Once you see the desired song list, you can save it to a .csv
    file with the --save option.

    The --connective option allows you to specify how multiple
    options are evaluated (e.g. OR means at least one of the options match, and AND means
    they all must match).

    Options can be mixed and matched except for --sql."""
    if connective.upper() not in ["OR", "AND"]:
        typer.echo("Connective must be either OR or AND.")
        return
    if sql:
        sql_query = sql
    else:
        sql_query = create_query(
            title, metadata, favorite, tag, genre, note, sources, voices, connective
        )
    if debug:
        typer.echo(f"query: {sql_query}")
    db = f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}'
    conn = duckdb.connect(db)
    if save:
        conn.execute(f"copy ({sql_query}) to '{save}' (header);")
        if os.path.getsize(save) <= 10:
            os.remove(save)
            oops(f"no songs match your query, {save} wasn't created")
    else:
        typer.echo(format_query_result(conn.execute(sql_query).fetchall()))


@app.command()
def metadata(
    music: str = typer.Argument(
        ...,
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id". You can specify "LAST" for last song streamed.',
    ),
    delete: bool = typer.Option(
        None,
        help="Delete specified option values.",
    ),
    title: str = typer.Option(
        None,
        help="Add/update song title.",
    ),
    favorite: bool = typer.Option(False, help="Add to favorites."),
    tag: List[str] = typer.Option([], help="A list of tags, provided separately."),
    genre: List[str] = typer.Option([], help="A list of genres, provided separately."),
    note: str = typer.Option(
        None,
        help="Add short notes via command line or specify a plain text file to load long form notes.",
    ),
    backup: bool = typer.Option(
        False,
        help="Export metadata to a .csv file if you need to rerun init and later restore matching metadata.",
    ),
    restore: bool = typer.Option(
        False,
        help="Restore metadata from a .csv file if you need to rerun init and later restore matching metadata.",
    ),
):
    """Add user metadata to music to supplement the optional MIDI event metadata embedded in your song files.
    User metadata is stored in your catalog database and is added to your music by using the query command
    to identify the specific songs you want to specify metadata for. You can also use the --backup and --restore if
    you wish to re-initialize your music collection and restore your metadata later."""

    def compose_related_values(table, values, keys):
        for key in keys:
            for value in values:
                if delete:
                    conn.execute(
                        f"delete from {table} where id = '{key}' and value = '{value}'"
                    )
                else:
                    try:
                        conn.execute(f"insert into {table} values ('{key}', '{value}')")
                    except:  # ignore duplicates...
                        pass

    keys = list_music(music)
    if os.path.isfile(music) and is_midi(music):
        keys.append(os.path.splitext(os.path.basename(music))[0])
    elif os.path.isdir(music):
        for file_name in os.listdir(music):
            if is_midi(file_name):
                keys.append(os.path.splitext(os.path.basename(file_name))[0])
    elif music.lower().endswith(".csv") and os.path.exists(music):
        keys = list(
            map(
                lambda x: x.get("id"),
                csv.DictReader(open(music)),
            )
        )
    elif music.endswith(".csv") and (backup or restore):
        pass
    else:
        oops(
            "music must be a song list, valid midi file ending .mid, or directory full of midi files"
        )
        return
    set_clause = []
    db = f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}'
    if not os.path.exists(db):
        oops(f"catalog {db} doesn't exist")
        return
    conn = duckdb.connect(db)
    if backup or restore:
        if music.endswith(".csv"):
            if backup:
                conn.execute(
                    f"""
                    COPY (SELECT id, favorite, note FROM catalog) TO '{music}' (DELIMITER ',', HEADER);
                    COPY (SELECT id, value FROM tag) TO '{music[:-4]}.tag.csv' (DELIMITER ',', HEADER);
                    COPY (SELECT id, value FROM genre) TO '{music[:-4]}.genre.csv' (DELIMITER ',', HEADER);
                    """
                )
            elif restore:
                try:
                    conn.execute(
                        f"""
                        CREATE TEMPORARY TABLE temp_restore (id VARCHAR, favorite BOOLEAN, note VARCHAR);
                        COPY temp_restore FROM '{music}' (DELIMITER ',', HEADER);
                        UPDATE catalog
                            SET 
                                favorite = (SELECT favorite FROM temp_restore WHERE temp_restore.id = catalog.id),
                                note = (SELECT note FROM temp_restore WHERE temp_restore.id = catalog.id)
                            WHERE EXISTS (SELECT 1 FROM temp_restore WHERE temp_restore.id = catalog.id);
                        DROP TABLE temp_restore;

                        -- Step 1: Create temporary tables and import data
                        CREATE TEMPORARY TABLE temp_tag (id VARCHAR, value VARCHAR);
                        CREATE TEMPORARY TABLE temp_genre (id VARCHAR, value VARCHAR);
                        COPY temp_tag FROM '{music[:-4]}.tag.csv' (DELIMITER ',', HEADER);
                        COPY temp_genre FROM '{music[:-4]}.genre.csv' (DELIMITER ',', HEADER);
                        -- Step 2: 'Upsert' into the main tables from the temporary tables
                        -- Update existing records
                        UPDATE tag
                            SET value = (SELECT value FROM temp_tag WHERE temp_tag.id = tag.id),
                            WHERE EXISTS (SELECT 1 FROM temp_tag WHERE temp_tag.id = tag.id);
                        UPDATE genre
                            SET value = (SELECT value FROM temp_genre WHERE temp_genre.id = genre.id),
                            WHERE EXISTS (SELECT 1 FROM temp_genre WHERE temp_genre.id = genre.id);
                        -- Insert new records
                        INSERT INTO tag (id, value)
                            SELECT id, value
                            FROM temp_tag
                            WHERE NOT EXISTS (SELECT 1 FROM tag WHERE tag.id = temp_tag.id);
                        INSERT INTO genre (id, value)
                            SELECT id, value
                            FROM temp_genre
                            WHERE NOT EXISTS (
                                SELECT 1 FROM genre WHERE genre.id = temp_genre.id
                            );
                        DROP TABLE temp_tag;
                        DROP TABLE temp_genre;
                        """
                    )
                except:
                    oops("you've already restored your metadata from this backup set")
            return
        else:
            oops(f"backup and restore options only works with a .csv file")
            return
    if title:
        if delete:
            set_clause.append("title = null")
        else:
            set_clause.append("title = '" + title.replace("'", "''") + "'")
    if favorite:
        set_clause.append(f"favorite = {'FALSE' if delete else 'TRUE'}")
    if tag:
        compose_related_values("tag", tag, keys)
    if genre:
        compose_related_values("genre", genre, keys)
    if note:
        if os.path.exists(note):
            note = open(note).read()
        if delete:
            set_clause.append("note = null")
        else:
            set_clause.append("note = '" + note.replace("'", "''") + "'")
    if len(set_clause) > 0:
        try:
            conn.execute(
                f"update catalog set {','.join(set_clause)} where id in {str(tuple(keys))}"
            )
        except:
            oops(
                "metdata can only be added to music in your catalog, not standalone folders/MIDI files"
            )


@app.command()
def fields():
    """Show the field names and types from your catalog database tables that you can use for advanced queries."""
    db = f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}'
    conn = duckdb.connect(db)
    for table in ["catalog", "tag", "genre"]:
        cols = conn.execute(
            f"select column_name, data_type from information_schema.columns where table_name = '{table}'"
        ).fetchall()
        typer.echo(f"table {table} fields:")
        for col in cols:
            typer.echo(f"  {col[0]}: {col[1]}")


@app.command()
def panic(
    device: str = typer.Option(
        settings.get("device", "Clavinova Port 1"),
        help='MIDI device to panic reset (e.g. "Clavinova Port 1" for USB, "Network Clavinova for WIFI, etc.))',
    ),
):
    """Send MIDI panic to turn off any hung notes."""
    with mido.open_output(device) as outport:
        for channel in range(16):  # MIDI channels 0-15
            for note in range(128):  # MIDI notes 0-127
                outport.send(mido.Message("note_off", note=note, channel=channel))


@app.command()
def db(
    init: bool = typer.Option(
        False,
        help="Initialize just the catalog database, useful if you break things while experimenting.",
    )
):
    """Analyze music catalog database with duckdb (enter ".quit" to exit when finished)."""
    if init:
        create_db(settings.get("catalog"))
    os.system(f'duckdb {pathlib.Path(settings.get("catalog")) / "catalog.db"}')


if __name__ == "__main__":
    app()
