#!/usr/bin/env python3

# Copyright (c) 2023 Dirk Leas
# This software is released under the MIT License.
# https://opensource.org/licenses/MIT

#
# miditoyz - care and feeding for you midi song collection
#
# todo:
#   stream:
#       - add windows notification support via win10toast
#       - preparse songs looking for other instruments via track titles or
#         sequencer_specific meta events, plus add extra cli arg "genre" and append
#         to event.track_name for preference key mapping
#         (e.g. "Jazz Drums" => (0, 0, 1) Jazz Brush Expanded)
#       - consider integrating music/folder and song metadata like genre,
#         favorites, wikipedia summaries, etc. renderable to stdout
#       - consider advanced analytics in clav repo datalist.ipynb for resolving
#         sequencer_specific events or metaMessage.track[0[]['title] to resolve
#         voices for voice_preferences
#
# notes/references:
#   - reference song with rich meta, sysex and sequencer_specific events in my
#     personal collection:
#       clav.toys/more clav files/2.NEW FollowLights/02.Prelude.s944.mid
#   - catalog list format: [{"title": "Autumn Leaves", "song": "hash.mid"}, ...]
#

import os, hashlib, shutil, json, parse, pathlib, platform, pickle, mido, typer, sh
from collections import defaultdict
from music21 import midi

homedir = pathlib.Path.home()
settings = json.load(open(f"{homedir}/.miditoyz/settings.json"))
voice_preferences = {
    tuple(v[0]): tuple(v[1]) for k, v in settings.get("voices").items()
}

app = typer.Typer()


## building blocks...
def dump_midi(filename: str, metadata: bool = False):
    """Dump a MIDI file in raw text format, optionally metadata only"""
    mf = midi.MidiFile()
    mf.open(filename)
    mf.read()
    mf.close()

    dump = []
    for i, track in enumerate(mf.tracks):
        time_delta = time_total = 0
        for event in track.events:
            if isinstance(event, midi.DeltaTime):
                time_delta = event.time
                time_total += event.time
            elif (
                metadata
                and hasattr(event.type, "name")
                and (
                    event.type.name in ["NOTE_ON", "NOTE_OFF", "PITCH_BEND"]
                    or (
                        event.type.name == "CONTROLLER_CHANGE"
                        and not event.parameter1 in [0, 32]
                    )
                    or event.type.name == "END_OF_TRACK"
                )
            ):
                pass
            else:
                dump.append(
                    f"{str(event).replace('<music21.midi.MidiEvent ', '')[:-1]}, time={time_delta}, clock={time_total}"
                )
    return dump


def get_track_channel_voices(midi_filename, voices):
    typer.echo(f"song file: {midi_filename}")
    with mido.MidiFile(midi_filename) as mid:
        for i, track in enumerate(mid.tracks):
            channels = defaultdict(dict)
            typer.echo(f"  track: {i+1}")
            for msg in track:
                if msg.type == "track_name":
                    typer.echo(f'    track name: {track.name.strip() or "n/a"}')
                elif msg.type == "control_change" and msg.control == 0:
                    channels[msg.channel]["msb"] = msg.value
                elif msg.type == "control_change" and msg.control == 32:
                    channels[msg.channel]["lsb"] = msg.value
                elif msg.type == "program_change":
                    channels[msg.channel]["pc"] = msg.program + 1
            for channel in sorted(channels.keys()):
                voice = (
                    channels.get(channel).get("msb", 0),
                    channels.get(channel).get("lsb", 0),
                    channels.get(channel).get("pc", 1),
                )
                typer.echo(
                    f"      channel {channel}: {voices.get(voice, voice)}, datalist voice MSB, LSB, PC: {voice[0]}, {voice[1]}, {voice[2]}"
                )


def is_midi(filename):
    return filename.lower().endswith((".midi", ".mid"))


def get_title(dump):
    """get first title from dump"""
    event = next(filter(lambda x: x.startswith("SEQUENCE_TRACK_NAME"), dump), None)
    if not event:
        return "n/a"
    else:
        return parse.parse(
            "SEQUENCE_TRACK_NAME, track={track}, channel={channel}, data=b{title}, time={time}",
            event,
        )["title"][1:-1]


def ingest_music(source_directory, destination_directory):
    """ingest music from source_directory into destination_directory"""
    typer.echo(
        f"ingesting source_directory: {source_directory} => destination_directory: {destination_directory}..."
    )
    # locate candidate songs...
    typer.echo(f"  scanning for duplicate songs...")
    songs = {}  # defaultdict(lambda: defaultdict(list)) not working...
    total_songs = 0  # total songs found, including dups...
    for dirpath, _, filenames in os.walk(source_directory):
        for filename in filenames:
            if is_midi(filename):
                total_songs += 1
                song = os.path.join(dirpath, filename)
                hash = hashlib.md5(open(song, "rb").read()).hexdigest()
                if not hash in songs:
                    songs[hash] = {"sources": []}
                songs[hash]["sources"].append(song)

    # hash for duplicates...
    typer.echo(
        f"  found {total_songs} total songs of which {len(songs)} are actually unique..."
    )

    # identify broken/unstreamable songs...
    typer.echo(
        f"  scanning for broken or invalid song files, this will take a while..."
    )
    songs_broken = []
    for hash in songs.keys():
        try:
            mido.MidiFile(f"{homedir}/h4x/clav.toys.unique/{hash}.mid")
        except:
            songs_broken.append(hash)
    # tbd: add broken identifier to catalog or remove broken songs...
    typer.echo(
        f'  {len(songs_broken) / len(songs) * 100:.2f}% of songs are "broken" and will be ignored...'
    )

    # copy unique songs to destination_directory...
    typer.echo("  copying unique songs to destination_directory, again patience...")
    if not len(os.listdir(destination_directory)) == len(songs.keys()):
        for hash, v in songs.items():  # fyi, this took 1m5.3s
            shutil.copyfile(v["sources"][0], f"{destination_directory}/{hash}.mid")

    # generate catalog...
    typer.echo("  generating song catalog...")

    # add metadata to catalog using "mididump --metadata"...
    for song in [s for s in songs.keys() if s not in songs_broken]:
        dump = dump_midi(f"{destination_directory}/{song}.mid", metadata=True)
        songs[song] = {
            **{"title": get_title(dump), "dump": dump},
            **songs[song],
        }
    json.dump(songs, open(f"{destination_directory}/catalog.json", "w"), indent=2)
    settings = json.load(open(f"{homedir}/.miditoyz/settings.json"))
    settings["catalog"] = f"{destination_directory}/catalog.json"
    json.dump(settings, open(f"{homedir}/.miditoyz/settings.json", "w"))
    typer.echo(
        f"  song catalog saved to {destination_directory}/catalog.json -- all set, enjoy!!!"
    )


def notify(title, subtitle):
    """display notification on macos, tested on ventura"""
    try:
        sh.osascript(e=f'display notification "{title}" with title "{subtitle}"')
    except:
        pass


def serialize_settings(new_settings):
    """update settings.json with specified dictionary"""
    settings.update(new_settings)
    json.dump(
        settings,
        open(f"{homedir}/.miditoyz/settings.json", "w"),
    )


def song_title(midi):
    """return song title from midi file object"""
    return tuple((e.name for e in midi.tracks[0] if e.type == "track_name"))[0]


def revoice(ch, msb, lsb, pc):
    """revoice by generating list of bank select and program change messages"""
    typer.echo(f"  revoicing ch: {ch}, msb: {msb}, lsb: {lsb}, pc: {pc}")
    return [
        mido.Message("control_change", channel=ch, control=0, value=msb, time=0),
        mido.Message("control_change", channel=ch, control=32, value=lsb, time=0),
        mido.Message("program_change", channel=ch, program=pc - 1, time=0),
    ]


def stream_revoiced(songfile, index, song_count, voice_preferences, device):
    """restream midi file with revoiced program changes based on voice preferences"""
    channels = {}
    ch = lsb = msb = 0
    pc = 1
    serialize_settings({"bookmark": index + 1})
    midi = mido.MidiFile(songfile)
    title = song_title(midi) or "oops, missing title"
    typer.echo(f"{title} ({songfile}), song {index+1} of {song_count}")
    if platform.system() == "Darwin":
        notify(f"{'/'.join(songfile.split('/')[-2:])}, #{index+1}", title)
    for event in midi.play():
        if event.type == "control_change" and event.control == 0:
            msb = event.value
        elif event.type == "control_change" and event.control == 32:
            lsb = event.value
        elif event.type == "program_change":
            ch = event.channel
            voice = (msb, lsb, event.program + 1)
            voice_preference = voice_preferences.get(voice, voice)
            typer.echo(
                f"  voicing ch: {ch}, pc: {event.program+1}, voice={voice}, "
                + f"voice_preference={voice_preference}, revoicing={tuple([*[ch], *voice_preference])}"
            )
            for voice_event in revoice(*tuple([*[ch], *voice_preference])):
                device.send(voice_event)
        elif event.type == "sequencer_specific":
            typer.echo(f"  seq: {event}")
        else:
            device.send(event)


## cli commands...
@app.command()
def init(
    source_directory: pathlib.Path = typer.Argument(
        ..., help="directory full of MIDI songs to clean up"
    ),
    destination_directory: pathlib.Path = typer.Argument(
        ...,
        help="directory for cleaned up MIDI songs with duplicates removed and catalog generated",
    ),
):
    """generate a new music collection from a source directory in destination directory without duplicate songs"""
    # create destination_directory if it doesn't exist...
    if not os.path.exists(destination_directory):
        os.makedirs(destination_directory)
    ingest_music(source_directory, destination_directory)


@app.command()
def devices():
    """list available midi devices"""
    typer.echo(f"available midi device(s): {', '.join(set(mido.get_output_names()))}")


@app.command()
def stream(
    music: str = typer.Option(
        settings.get("music"),  # default to last music
        help='MIDI music file, directory full of music, or catalog list to stream. catalog list is a JSON file containing list of song "keys"',
    ),
    bookmark: int = typer.Option(
        settings.get("bookmark", 0),
        help="Bookmark for last song line number from music folder's _songlist.txt to start playing",
    ),
    device: str = typer.Option(
        settings.get("device", "Clavinova Port 1"),
        help='MIDI device to stream to (e.g. "Clavinova Port 1" for USB, "Network Clavinova for WIFI, etc.))',
    ),
):
    """Stream music as a catalog song list, a midi file, or directory full of midi files to a midi device with using
    bank selection and program changes based on voice preferences stored in "~/.miditoyz/settings.json"
    and created automatically the first time you stream. Catalog song lists are JSON files with the format:
    [{"title": "Autumn Leaves", "song": "hash.mid"}, ...] created from your collections "catalog.json" list.
    Command line options are remembered between streaming sessions, so
    subsequent streamings pick up from the last song played. Bookmark values are based on line numbers
    from the directory's "_songlist.txt" file, which starts with a title and blank line, so the first
    song is line 3 (e.g. "--bookmark 3"). Bookmark values are reset to 3 if the music is a song rather than
    a directory, is either too low/high, or if the music is different than the last time you streamed.
    """
    is_song = music.lower().endswith(".mid")
    is_catalog_list = music.lower().endswith(".json")
    if bookmark < 0 or music != settings.get("music") or is_song:
        bookmark = 1
    serialize_settings({"music": music, "device": device, "bookmark": bookmark})
    device = mido.open_output(device)
    if is_song:  # stream file...
        songs = [
            music,
        ]
    elif os.path.isdir(music):  # stream folder's midi files...
        songs = sorted(
            [f"{music}/{x}" for x in os.listdir(music) if x.lower().endswith(".mid")]
        )
    elif is_catalog_list:  # stream or catalog list...
        # catalog list format: [{"title": "Autumn Leaves", "song": "hash.mid"}, ...]
        songs = list(
            map(
                lambda x: f'{settings.get("catalog")[:-13]}/{x.get("song")}',
                json.load(open(music)),
            )
        )
    else:
        typer.echo(
            "oops, music must be a catalog list, midi file, or directory full of midi files"
        )
        return
    if bookmark > len(songs):
        bookmark = 1
        typer.echo(
            f"{os.linesep}oops, your bookmark is beyond the last song in your music -- starting from the beginning...{os.linesep}"
        )
    try:  # revoice and stream songs...
        for skip, song in enumerate(songs):
            if skip >= bookmark - 1:
                stream_revoiced(song, skip, len(songs), voice_preferences, device)
    except:  # skip broken songs...
        pass


@app.command()
def voices(
    midi_file: str = typer.Argument(..., help="MIDI file for voice list"),
    voices: str = typer.Option(
        f"{pathlib.Path.home()}/.miditoyz/datalist.pickle",
        help="Pickle file of voices, see official clavinova datalist.pdf",
    ),
    detail: bool = typer.Option(
        False,
        help="include voice MSB, LSB, PC voice values for searching datalist csv or pdf",
    ),
):
    """Generate a list of voices for each track in a midi file"""
    get_track_channel_voices(midi_file, pickle.load(open(voices, "rb")))


@app.command()
def dump(
    song: str = typer.Argument(
        ..., help="The path to the MIDI song file to be analyzed"
    ),
    metadata: bool = typer.Option(False, help="Show only metadata"),
):
    """Dump a MIDI file in raw text format. if you need hashdump-esque details, use "midiraw --debug" instead"""
    for dump in dump_midi(song, metadata):
        typer.echo(dump)


@app.command()
def raw(
    midi_file: str = typer.Argument(..., help="MIDI file to dump in raw format"),
    debug: bool = typer.Option(False, help="Enable debug mode"),
):
    """Dump a MIDI file in raw text format, optionally with hexdump output."""
    mido.MidiFile(midi_file, debug=debug).print_tracks()


if __name__ == "__main__":
    app()
