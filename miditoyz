#!/usr/bin/env python3

# Copyright (c) 2023 Dirk Leas
# This software is released under the MIT License.
# https://opensource.org/licenses/MIT

#
# miditoyz - care and feeding for you midi song collection
#
# todo:
#   general:
#       - tbd
#   init:
#       - scan songs looking for other instruments via track titles or
#         sequencer_specific meta events, plus add extra cli arg "genre" and append
#         to event.track_name for preference key mapping
#         (e.g. "Jazz Drums" => (0, 0, 1) Jazz Brush Expanded)
#       - consider integrating music/folder and song metadata like genre,
#         favorites, wikipedia summaries, etc. renderable to stdout
#       - consider advanced analytics in clav repo datalist.ipynb for resolving
#         sequencer_specific events or metaMessage.track[0[]['title] to resolve
#         voices for voice_preferences
#
# notes/references:
#   - duckdb is used for catalog and metadata storage
#   - reference song with rich meta, sysex and sequencer_specific events in my
#     personal collection:
#       clav.toys/more clav files/2.NEW FollowLights/02.Prelude.s944.mid
#

import os, hashlib, shutil, json, csv, pathlib, platform, pickle, time, datetime, random, mido, music21, typer, parse, duckdb, jinja2
from collections import defaultdict

homedir = pathlib.Path.home()
if not os.path.exists(pathlib.Path(homedir) / ".miditoyz"):
    typer.echo(
        "oops, you need to complete all the Installation/Setup steps from the project README.md documentation before you can use miditoyz!!!"
    )
    exit(1)

settings = json.load(open(pathlib.Path(homedir) / ".miditoyz" / "settings.json"))
voice_preferences = {
    tuple(v[0]): tuple(v[1]) for k, v in settings.get("voices").items()
}

app = typer.Typer()


## building blocks...
def is_midi(filename: str) -> bool:
    return filename.lower().endswith((".midi", ".mid"))


def normalize_midi(file: str) -> str:
    """Optionally prefix catalog path for unqualified catalog midi files and append .mid if not specified"""
    if not is_midi(file):  # add .mid if not specified
        file += ".mid"
    catalog_path = str(
        pathlib.Path(settings.get("catalog")) / file
    )  # prefix catalog path
    if is_midi(file) and not os.path.exists(file) and os.path.exists(catalog_path):
        return catalog_path
    else:
        return file


def get_track_channel_voices(midi_filename: str, voices: dict) -> None:
    typer.echo(f"song file: {midi_filename}")
    with mido.MidiFile(midi_filename) as mid:
        for i, track in enumerate(mid.tracks):
            channels = defaultdict(dict)
            typer.echo(f"  track: {i+1}")
            for msg in track:
                if msg.type == "track_name":
                    typer.echo(f'    track name: {track.name.strip() or "n/a"}')
                elif msg.type == "control_change" and msg.control == 0:
                    channels[msg.channel]["msb"] = msg.value
                elif msg.type == "control_change" and msg.control == 32:
                    channels[msg.channel]["lsb"] = msg.value
                elif msg.type == "program_change":
                    channels[msg.channel]["pc"] = msg.program + 1
            for channel in sorted(channels.keys()):
                voice = (
                    channels.get(channel).get("msb", 0),
                    channels.get(channel).get("lsb", 0),
                    channels.get(channel).get("pc", 1),
                )
                if voice in voices.keys():
                    typer.echo(
                        f"      channel {channel+1}: {voices.get(voice, voice)}, datalist voice MSB, LSB, PC: {voice[0]}, {voice[1]}, {voice[2]}"
                    )
                else:
                    typer.echo(
                        f"      channel {channel+1}: unrecognized voice, MSB, LSB, PC: {voice[0]}, {voice[1]}, {voice[2]}"
                    )


def get_title_music21(dump: list) -> str:
    """get first title from dump"""
    event = next(filter(lambda x: x.startswith("SEQUENCE_TRACK_NAME"), dump), None)
    if not event:
        return "untitled"
    else:
        return parse.parse(
            "SEQUENCE_TRACK_NAME, track={track}, channel={channel}, data=b{title}, time={time}",
            event,
        )["title"][1:-1]


def get_title_mido(midi: mido.MidiFile) -> str:
    """return song title from midi file object"""
    titles = [e.name for e in midi.tracks[0] if e.type == "track_name"]
    return titles[0] if titles and len(titles) > 0 else "untitled"


def create_db(catalog: str) -> None:
    db = f'{pathlib.Path(catalog) / "catalog.db"}'
    if os.path.exists(db):
        os.remove(db)
    typer.echo(f"  creating duckdb database {db}, just a sec...")
    conn = duckdb.connect(db, config={"max_memory": "5G"})
    catalog_data = [
        {"id": k, **v} for k, v in json.load(open(db.replace(".db", ".json"))).items()
    ]
    open(db.replace(".db", "_flat.json"), "w").write(json.dumps(catalog_data))
    catalog_flat = db.replace(".db", "_flat.json")
    conn.execute(
        "create table catalog as select * from read_json('"
        + catalog_flat
        + "', columns={id: 'varchar', title: 'varchar', broken_mido: 'boolean', broken_music21: 'boolean', dump: 'varchar', sources: 'varchar'});"
    )
    conn.execute("create index idx_catalog_id on catalog (id);")
    conn.commit()
    conn.close()
    os.remove(catalog_flat)


def ingest_music(source_directory: str, destination_directory: str) -> int:
    """ingest music from source_directory into destination_directory"""
    typer.echo(
        f"ingesting source_directory: {source_directory} => destination_directory: {destination_directory}..."
    )
    # locate candidate songs, hash for duplicates...
    typer.echo(f"  scanning for duplicate songs...")
    songs = defaultdict(lambda: defaultdict(list))
    total_songs = 0  # total songs found, including dups...
    for dirpath, _, filenames in os.walk(source_directory):
        for filename in filenames:
            if is_midi(filename):
                total_songs += 1
                song = os.path.join(dirpath, filename)
                hash = hashlib.md5(open(song, "rb").read()).hexdigest()
                songs[hash]["sources"].append(song)
    typer.echo(
        f"  found {total_songs} total songs of which {len(songs)} are actually unique..."
    )

    # identify mido broken/unstreamable songs...
    typer.echo(
        f"  scanning for broken or invalid song files, this will take a while..."
    )
    songs_broken_mido = set()
    for song in [x["sources"][0] for x in songs.values()]:
        try:
            mido.MidiFile(song)
        except:
            songs_broken_mido.add(hash)

    # copy unique songs to destination_directory...
    typer.echo("  copying unique songs to destination_directory, again patience...")
    # if not len(os.listdir(destination_directory)) == len(songs.keys()):
    for hash, v in songs.items():  # fyi, this took 1m5.3s
        shutil.copyfile(
            v["sources"][0], pathlib.Path(destination_directory) / f"{hash}.mid"
        )

    # add metadata to catalog using dump_midi metadata...
    songs_broken_music21 = set()
    for song in songs.keys():  # [s for s in songs.keys()]:
        try:
            dump = dump_midi(
                pathlib.Path(destination_directory) / f"{song}.mid", metadata=True
            )
            songs[song] = {
                **{
                    "title": get_title_music21(dump),
                    "broken_mido": song in songs_broken_mido,
                    "broken_music21": False,
                    "dump": dump,
                    "timestamp": datetime.datetime.now().isoformat(),
                },
                **songs[song],
            }
        except:
            songs_broken_music21.add(song)
            songs[song] = {
                **{
                    "title": get_title_music21(dump),
                    "broken_mido": song in songs_broken_mido,
                    "broken_music21": True,
                    "dump": "n/a",
                    "timestamp": datetime.datetime.now().isoformat(),
                },
                **songs[song],
            }
    typer.echo(
        f'  {(len(songs_broken_mido) + len(songs_broken_music21)) / len(songs) * 100:.2f}% of songs are "broken" and have been logged...'
    )
    json.dump(
        songs, open(pathlib.Path(destination_directory) / "catalog.json", "w"), indent=2
    )
    settings = json.load(open(pathlib.Path(homedir) / ".miditoyz" / "settings.json"))
    settings["catalog"] = str(pathlib.Path(destination_directory))
    settings["music"] = ""
    json.dump(
        settings, open(pathlib.Path(homedir) / ".miditoyz" / "settings.json", "w")
    )
    create_db(settings.get("catalog"))
    typer.echo(
        f"  song catalog saved to {pathlib.Path(destination_directory) / 'catalog.json'}"
    )
    return len(songs)


def format_query_result(data: list) -> str:
    if not data:
        typer.echo("oops, no songs match your query...")
        return
    HORIZONTAL = "─"
    VERTICAL = "│"
    TOP_LEFT = "┌"
    TOP_RIGHT = "┐"
    BOTTOM_LEFT = "└"
    BOTTOM_RIGHT = "┘"
    T_LEFT = "├"
    T_RIGHT = "┤"
    T_TOP = "┬"
    T_BOTTOM = "┴"
    CROSS = "┼"
    max_width_col1 = max(len(row[0]) for row in data)
    max_width_col2 = max(len(row[1]) for row in data)
    header_top = f"{TOP_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{T_TOP}{HORIZONTAL * (max_width_col2 + 2)}{TOP_RIGHT}"
    header_row = f"{VERTICAL} {'title'.ljust(max_width_col1)} {VERTICAL} {'id'.ljust(max_width_col2)} {VERTICAL}"
    header_middle = f"{T_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{CROSS}{HORIZONTAL * (max_width_col2 + 2)}{T_RIGHT}"
    rows_box = [header_top, header_row, header_middle]
    for row in data:
        rows_box.append(
            f"{VERTICAL} {row[0].strip().ljust(max_width_col1)} {VERTICAL} {row[1].strip().ljust(max_width_col2)} {VERTICAL}"
        )
    table_bottom = f"{BOTTOM_LEFT}{HORIZONTAL * (max_width_col1 + 2)}{T_BOTTOM}{HORIZONTAL * (max_width_col2 + 2)}{BOTTOM_RIGHT}"
    rows_box.append(table_bottom)
    return "\n".join(rows_box)


def notify(title: str, subtitle: str) -> None:
    """display notification on macos, tested on ventura"""
    try:
        if platform.system() == "Darwin":
            import sh

            sh.osascript(e=f'display notification "{title}" with title "{subtitle}"')
        elif platform.system() == "Windows":
            import notifypy

            notification = notifypy.Notify()
            notification.application_name = "miditoyz - streaming..."
            notification.title = subtitle
            notification.message = title
            notification.send(block=False)
    except:
        pass


def serialize_settings(new_settings: dict) -> None:
    """update settings.json with specified dictionary"""
    settings.update(new_settings)
    json.dump(
        settings,
        open(pathlib.Path(homedir) / ".miditoyz" / "settings.json", "w"),
    )


def generate_midi_voice_events(ch: int, msb: int, lsb: int, pc: int) -> list:
    """generate midi voice events for bank select and program change messages"""
    return [
        mido.Message("control_change", channel=ch, control=0, value=msb, time=0),
        mido.Message("control_change", channel=ch, control=32, value=lsb, time=0),
        mido.Message("program_change", channel=ch, program=pc - 1, time=0),
    ]


def stream_revoiced(
    songfile: str, index: int, song_count: int, voice_preferences: dict, device
) -> None:
    """revoice midi file with voice preferences"""
    channels = defaultdict(dict)
    serialize_settings({"bookmark": index + 1})
    midi = mido.MidiFile(songfile)
    title = get_title_mido(midi)
    typer.echo(f"{title} ({songfile}), song {index+1} of {song_count}")
    notify(f"{'/'.join(songfile.split('/')[-2:])}, #{index+1}", title)
    for event in midi.play():
        if event.type == "control_change" and event.control == 0:
            channels[event.channel]["msb"] = event.value
        elif event.type == "control_change" and event.control == 32:
            channels[event.channel]["lsb"] = event.value
        elif event.type == "program_change":
            ch = event.channel
            channels[event.channel]["pc"] = event.program + 1
            voice = (
                channels.get(ch).get("msb", 0),
                channels.get(ch).get("lsb", 0),
                channels.get(ch).get("pc", 1),
            )
            voice_preference = voice_preferences.get(voice, voice)
            if voice == voice_preference:
                typer.echo(f"  voicing channel {ch} with voice {voice}")
            else:
                typer.echo(
                    f"  revoicing channel {ch} from voice {voice} to preferred voice {voice_preference}"
                )
            for voice_event in generate_midi_voice_events(
                *tuple([*[ch], *voice_preference])
            ):
                device.send(voice_event)
        elif event.type == "sequencer_specific":
            typer.echo(f"  seq: {event}")
        else:
            device.send(event)


def merge_json_metadata(data, types_to_merge=["text", "copyright", "lyrics"]):
    merged_records = defaultdict(str)
    first_record_index = {}
    output_data = []

    # Iterate through the list to find and merge records of specified types
    for i, record in enumerate(data):
        record_type = record.get("type")
        if record_type in types_to_merge:
            if record_type not in first_record_index:
                first_record_index[record_type] = i
                merged_records[record_type] = record["text"]
            else:
                merged_records[record_type] += "\n" + record["text"]
        else:
            output_data.append(record)

    # Replace the first instance of each merged type with the merged text
    for record_type, index in first_record_index.items():
        output_data.insert(
            index, {"type": record_type, "text": merged_records[record_type], "time": 0}
        )

    return output_data


def dump_midi(filename: str, metadata: bool = False) -> list:
    """Dump a MIDI file in raw text format, optionally metadata only"""
    mf = music21.midi.MidiFile()
    mf.open(filename)
    try:
        mf.read()
    except:  # skip broken songs...
        typer.echo(f"oops, {filename} is a broken song file!")
        return []
    mf.close()

    dump = []
    for i, track in enumerate(mf.tracks):
        time_delta = time_total = 0
        for event in track.events:
            if isinstance(event, music21.midi.DeltaTime):
                time_delta = event.time
                time_total += event.time
            elif (
                metadata
                and hasattr(event.type, "name")
                and (
                    event.type.name in ["NOTE_ON", "NOTE_OFF", "PITCH_BEND"]
                    or (
                        event.type.name == "CONTROLLER_CHANGE"
                        and not event.parameter1 in [0, 32]
                    )
                    or event.type.name == "END_OF_TRACK"
                )
            ):
                pass
            else:
                dump.append(
                    f"{str(event).replace('<music21.midi.MidiEvent ', '')[:-1]}, time={time_delta}, clock={time_total}"
                )
    return dump


def dump_json(
    midi_file: str = typer.Argument(..., help="MIDI song file to convert to JSON."),
    metadata: bool = typer.Option(False, help="Show only metadata."),
    pretty: bool = typer.Option(False, help="Pretty print JSON output."),
):
    midi_file = normalize_midi(midi_file)
    if not os.path.exists(midi_file) or not is_midi(midi_file):
        typer.echo(
            f"oops, midi_file {midi_file} doesn't exist, doesn't end with .mid, or isn't a midi song file"
        )
        return
    try:
        mid = mido.MidiFile(midi_file)
    except:
        typer.echo(f"oops, {midi_file} is a broken song file!")
        return
    tracks = []
    for i, track in enumerate(mid.tracks):
        events = []
        for event in track:
            if metadata and (
                event.type in ["note_on", "note_off", "pitch_bend"]
                or (event.type == "control_change" and not event.control in [0, 32])
                or event.type == "end_of_track"
                or event.type.startswith("sequencer_specific")
            ):
                pass
            else:
                events.append(vars(event).copy())
        events = merge_json_metadata(events)
        tracks.append({"track": i, "events": events})
    song = (
        {
            "ticks_per_beat": mid.ticks_per_beat,
            "tracks": tracks,
        },
    )

    if pretty:
        typer.echo(
            jinja2.Environment()
            .from_string(open(pathlib.Path(homedir) / ".miditoyz" / "midi.j2").read())
            .render(song[0])
        )
    else:
        typer.echo(
            json.dumps(
                song,
                indent=2,
            )
        )


## cli commands...
@app.command()
def init(
    source_directory: pathlib.Path = typer.Argument(
        ..., help="Directory full of MIDI songs to clean up."
    ),
    destination_directory: pathlib.Path = typer.Argument(
        ...,
        help="Directory for cleaned up MIDI song collection with duplicates removed and catalog generated.",
    ),
):
    """Generate a new music collection from a source directory into a destination directory removing duplicates
    songs. Duplicates include same song in multiple directory paths, renamed versions of the same song, etc.
    that have identical song content "inside" the song MIDI file."""
    if not os.path.exists(source_directory):
        typer.echo(f"oops, source_directory {source_directory} doesn't exist")
        return
    if source_directory == destination_directory:
        typer.echo(
            f"oops, source_directory and destination_directory must be different"
        )
        return
    if not os.path.exists(destination_directory):
        os.makedirs(destination_directory)

    start_time = time.time()
    songs = ingest_music(source_directory, destination_directory)
    elapsed = (time.time() - start_time) / 60  # minutes
    typer.echo(
        f"  elapsed time was {elapsed:.2f} minutes, {elapsed/songs*1000:.2f} minutes/1000 songs..."
    )


@app.command()
def merge(
    source: str = typer.Argument(
        ..., help="Source catalog to merge into destination catalog."
    ),
    destination: str = typer.Argument(
        ...,
        help="Destination catalog to merge source catalog into, overriding duplicates with source songs.",
    ),
    backup: bool = typer.Option(
        True, help="Create destination catalog backup .zip archive before merging."
    ),
):
    """Merge source catalog into destination catalog, overwriting destination catalog songs with source catalog songs if there are any duplicates."""
    if (
        not os.path.exists(source)
        and os.path.isdir(source)
        and os.path.exists(pathlib.Path(destination) / "catalog.json")
    ):
        typer.echo(f"oops, source catalog {source} isn't a valid catalog!")
        return
    if (
        not os.path.exists(destination)
        and os.path.isdir(source)
        and os.path.exists(pathlib.Path(destination) / "catalog.json")
    ):
        typer.echo(f"oops, destination catalog {destination} isn't a valid catalog!")
        return
    typer.echo(
        f"merging source catalog {source} into destination catalog {destination}..."
    )
    if backup:
        typer.echo(f"  backing up destination catalog...")
        shutil.make_archive(
            f"{destination}.backup.{datetime.datetime.now().isoformat().replace(':', '.')}",
            "zip",
            destination,
        )
    typer.echo(f"  merging catalogs...")
    source_catalog = json.load(open(pathlib.Path(source) / "catalog.json"))
    destination_catalog = json.load(open(pathlib.Path(destination) / "catalog.json"))
    dupes = len(set(source_catalog).intersection(set(destination_catalog)))
    typer.echo(
        f"  merging {len(source_catalog)} source songs with destination: {len(destination_catalog)} destination songs, {dupes} duplicates..."
    )
    destination_catalog.update(source_catalog)
    json.dump(
        destination_catalog,
        open(pathlib.Path(destination) / "catalog.json", "w"),
        indent=2,
    )
    create_db(destination.replace(".json", ""))
    typer.echo(f"  merged catalog saved to {destination}")


@app.command()
def devices():
    """List currently connected midi output devices attached via USB, WIFI, or Bluetooth."""
    typer.echo("connected midi device(s):")
    for device in mido.get_output_names():
        typer.echo(f'  "{device}"')


@app.command()
def stream(
    music: str = typer.Option(
        settings.get("music") or settings.get("catalog"),  # default to last music
        help='MIDI song file, directory full of music, or song list to stream. A song list is a CSV file with a mandatory header "title,id".',
    ),
    bookmark: int = typer.Option(
        settings.get("bookmark", 0),
        help="Bookmark for last song played assuming you don't pick different music.",
    ),
    device: str = typer.Option(
        settings.get("device", "Clavinova Port 1"),
        help='MIDI device to stream to (e.g. "Clavinova Port 1" for USB, "Network Clavinova for WIFI, etc.))',
    ),
    shuffle: bool = typer.Option(False, help="Shuffle song order."),
    intermission: int = typer.Option(
        0, help="Add specified number of seconds intermission between songs."
    ),
    debug: bool = typer.Option(
        False,
        help="Debug output.))",
    ),
):
    """
    Stream music from a catalog song list, a midi file, or directory full of midi files to a midi device with using
    bank selection and program changes based on voice preferences stored in "~/.miditoyz/settings.json"
    and saved automatically each time you stream.
    Catalog song lists are CSV files with a mandatory header of "title,id" -- don't forget to use comma to separate for
    CSV fields, and double-quote fields with commas in them. Create song lists using the "query" command.
     Bookmark values are based on the sequential number of the
    song in the playlist or directory song list starting with 1.
    We do the right thing if you specify a bookmark number that's too big or small or your play different music than
    last time. Don't want to play your songs in order? Try the "shuffle" option. Your most important command line options are
    remembered between streaming sessions, so subsequent streamings pick up
    from the last song played if you don't include them (exceptions: shuffle, intermission, and debug).
    """
    try:  # pretest device...
        mido.open_output(device)
    except:
        typer.echo(
            f"oops, device {device} not found, please select from the following connected device list: {', '.join(set(mido.get_output_names()))}"
        )
        return
    if bookmark < 0 or music != settings.get("music") or is_midi(music):
        bookmark = 1
    serialize_settings({"music": music, "device": device, "bookmark": bookmark})
    if is_midi(music):  # stream file...
        music = normalize_midi(music)
        songs = [
            music,
        ]
    elif os.path.isdir(music):  # stream folder's midi files...
        songs = sorted(
            [
                f"{music}{os.sep}{x}"
                for x in os.listdir(music)
                if x.lower().endswith(".mid")
            ]
        )
    elif music.lower().endswith(".csv"):  # stream or catalog list...
        songs = list(  # includes header, format title,id
            map(
                lambda x: f'{settings.get("catalog")}{os.sep}{x.get("id")}.mid',
                csv.DictReader(open(music)),
            )
        )
    else:
        typer.echo(
            "oops, music must be a song list, valid midi file ending .mid, or directory full of midi files"
        )
        return
    if bookmark > len(songs):
        bookmark = 1
        typer.echo(
            f"{os.linesep}oops, your bookmark is beyond the last song in your music -- starting from the beginning...{os.linesep}"
        )
    try:  # revoice and stream songs...
        if shuffle:
            bookmark = 1
            random.shuffle(songs)
        device = mido.open_output(device)
        for skip, song in enumerate(songs):
            if skip >= bookmark - 1:
                stream_revoiced(song, skip, len(songs), voice_preferences, device)
                time.sleep(intermission)
    except:  # skip broken songs...
        if not debug:
            pass
        else:  # debug...
            raise


@app.command()
def voices(
    midi_file: str = typer.Argument(
        ..., help="MIDI song file to generate voice list for."
    ),
    voices: str = typer.Option(
        str(pathlib.Path(pathlib.Path.home()) / ".miditoyz" / "datalist.pickle"),
        help='Official Yamaha Clavinova "datalist" of voices. Check vendor documentation for other device voicing.',
    ),
    detail: bool = typer.Option(
        False,
        help="Include voice MSB, LSB, PC voice values for searching datalist csv or pdf for voice names.",
    ),
):
    """Generate a list of voices for each track in a midi song file."""
    midi_file = normalize_midi(midi_file)
    if not os.path.exists(midi_file) or not is_midi(midi_file):
        typer.echo(
            f"oops, midi_file {midi_file} doesn't exist, doesn't end with .mid, or isn't a midi song file"
        )
        return
    get_track_channel_voices(midi_file, pickle.load(open(voices, "rb")))


@app.command()
def dump(
    midi_file: str = typer.Argument(..., help="MIDI song file to be analyzed."),
    json: bool = typer.Option(False, help="MIDI song file output in JSON format."),
    metadata: bool = typer.Option(False, help="Show only metadata."),
    pretty: bool = typer.Option(
        False, help="Pretty print JSON output (only available with --json option)."
    ),
):
    """Dump a MIDI song file in raw text format. See also: "miditoyz raw --debug"."""
    midi_file = normalize_midi(midi_file)
    if not os.path.exists(midi_file) or not is_midi(midi_file):
        typer.echo(
            f"oops, midi_file {midi_file} doesn't exist, doesn't end with .mid, or isn't a midi song file"
        )
        return
    if json:
        dump_json(midi_file, metadata, pretty)
    else:
        for dump in dump_midi(midi_file, metadata):
            typer.echo(dump)


@app.command()
def raw(
    midi_file: str = typer.Argument(
        ..., help="MIDI file to analyze in extended raw debug format."
    ),
    debug: bool = typer.Option(False, help="Enable extended raw debug mode."),
):
    """Dump a MIDI song file in alternative raw text format with optionally with hexdump-style debug output. See also: "miditoyz dump --metadata"."""
    midi_file = normalize_midi(midi_file)
    if not os.path.exists(midi_file) or not is_midi(midi_file):
        typer.echo(
            f"oops, midi_file {midi_file} doesn't exist, doesn't end with .mid, or isn't a midi song file"
        )
        return
    mido.MidiFile(midi_file, debug=debug).print_tracks()


@app.command()
def verify(
    file_name: str = typer.Argument(
        ..., help="MIDI song, JSON, or CSV file to verify for correct format."
    )
):
    """Verify MIDI song file can be processed with mido and music21 packages or that a JSON or CSV file is the correct format."""
    if not os.path.exists(file_name) or not (
        is_midi(file_name)
        or file_name.lower().endswith(".json")
        or file_name.lower().endswith(".csv")
    ):
        typer.echo(
            f"oops, specified {file_name} doesn't exist or isn't a midi song, JSON, or CSV file"
        )
        return
    if is_midi(file_name):
        typer.echo(f"verifying {file_name} with mido and music21...")
        try:
            music21.midi.MidiFile()
            typer.echo(f"  music21 ok!")
            mido.MidiFile(file_name)
            typer.echo(f"  mido ok!")
        except:
            typer.echo(f"  oops, unable to verify with both mido and music21!")
    elif file_name.lower().endswith(".json"):
        typer.echo(f"verifying {file_name} is a valid JSON file...")
        try:
            json.load(open(file_name))
            typer.echo(f"  JSON format ok!")
        except:
            typer.echo(f"  oops, invalid format!")
    else:
        typer.echo(f"verifying {file_name} is a valid CSV file...")
        try:
            csv.DictReader(open(file_name))
            typer.echo(f"  CSV format ok!")
        except:
            typer.echo(f"  oops, invalid format!")


@app.command()
def catalog(
    catalog_directory: str = typer.Argument(
        ...,
        help="Alternative catalog directory from one of your miditoyz song collections.",
    )
):
    """Change to a new catalog file for streaming."""
    if os.path.exists(catalog_directory):
        serialize_settings({"catalog": catalog_directory, "music": "", "bookmark": 1})
    else:
        typer.echo(
            f"oops, {catalog_directory} doesn't exist or isn't a catalog json file"
        )


@app.command()
def info():
    """Show current miditoyz settings."""
    typer.echo(f"miditoyz settings:")
    for k, v in settings.items():
        if k == "voices":
            typer.echo(f"  {k}")
            for title, mapping in v.items():
                typer.echo(f"    {title}: {mapping}")
        else:
            typer.echo(f"  {k}:{os.linesep}    {v}")


@app.command()
def query(
    search: str = typer.Option(
        None,
        help="Query catalog for songs that match all the search words provided (e.g. Piano Bar would find Piano Bar and Bar Piano anywhere in the song metadata or sources). This options searches both song metadata and sources and is the most popular option.",
    ),
    title: str = typer.Option(None, help="Query catalog song title only."),
    metadata: str = typer.Option(None, help="Query catalog song metadata only."),
    sources: str = typer.Option(None, help="Query catalog song sources only."),
    sql: str = typer.Option(
        None,
        help="Query using SQL without needing to specify fields or FROM clauses, starting with WHERE clause to query catalog (omit WHERE prefix).",
    ),
    songlist_file: str = typer.Option(
        None,
        help="Save your song list query result to a .csv file for later streaming.",
    ),
    debug: bool = typer.Option(
        False, help="Show SQL generated based on selected query option."
    ),
):
    """Query a song list from your catalog for later streaming with several options to choose from depending on whether you prefer a simple or advanced option. Once you see the desired song list, you can save it to a .csv file for later streaming with the --songlist-file option."""

    def criteria(column, value):
        return f"lower({column}) like '%{value.lower()}%'"

    if title:
        search = " and ".join([criteria("title", x) for x in title.split()])
    elif metadata:
        search = " and ".join([criteria("dump", x) for x in metadata.split()])
    elif sources:
        search = " and ".join([criteria("sources", x) for x in sources.split()])
    elif sql:
        search = sql
    elif search:
        search = " or ".join(
            [
                "(" + " and ".join([criteria("dump", x) for x in search.split()]) + ")",
                "("
                + " and ".join([criteria("sources", x) for x in search.split()])
                + ")",
            ]
        )
    else:
        typer.echo(
            f"oops, you must use one of the following options to query songs from your catalog: --search, --title, --metadata, --sources, or --sql"
        )
        return
    if debug:
        typer.echo(f"query: select id, title from catalog where {search};")
    db = f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}'
    if songlist_file:
        query = f"copy (select title,id from catalog where {search}) to '{songlist_file}' (header);"
        duckdb.connect(db).execute(query)
        if os.path.getsize(songlist_file) <= 10:
            os.remove(songlist_file)
            typer.echo(
                f"oops, no songs match your query, {songlist_file} wasn't created..."
            )
    else:
        query = f"select title,id from catalog where {search};"
        typer.echo(format_query_result(duckdb.connect(db).execute(query).fetchall()))


@app.command()
def fields():
    """Show the fields in your catalog that you can use when querying a playlist from your catalog for later streaming."""
    db = f'{pathlib.Path(settings.get("catalog")) / "catalog.db"}'
    cols = (
        duckdb.connect(db)
        .execute(
            "select column_name from information_schema.columns where table_name='catalog'"
        )
        .fetchall()
    )
    typer.echo(f'catalog fields: {", ".join([col[0] for col in cols])}')


@app.command()
def panic(
    device: str = typer.Option(
        settings.get("device", "Clavinova Port 1"),
        help='MIDI device to panic reset (e.g. "Clavinova Port 1" for USB, "Network Clavinova for WIFI, etc.))',
    ),
):
    """Send MIDI panic to turn off any hung notes."""
    with mido.open_output(device) as outport:
        for channel in range(16):  # MIDI channels 0-15
            for note in range(128):  # MIDI notes 0-127
                outport.send(mido.Message("note_off", note=note, channel=channel))


@app.command()
def db(
    init: bool = typer.Option(
        False,
        help="Initialize just the catalog database, useful if you break things while experimenting.",
    )
):
    """Analyze music catalog database with duckdb (enter ".quit" to exit when finished)."""
    if init:
        create_db(settings.get("catalog"))
    os.system(f'duckdb {pathlib.Path(settings.get("catalog")) / "catalog.db"}')


if __name__ == "__main__":
    app()
